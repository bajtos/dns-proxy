#ifndef _DNS_PROXY__DNS_MESSAGE_
#define _DNS_PROXY__DNS_MESSAGE_

#include <ace/OS.h>
#include <string>
#include <ostream>
#include <vector>

namespace DNS
{

enum Opcode
{
	QUERY,
	IQUERY,
	STATUS
};

enum Rcode
{
	SUCCESS	 		= 0,
	FORMAT_ERROR	= 1,
	SERVER_FAILURE  = 2,
	NAME_ERROR		= 3,
	NOT_IMPLEMENTED = 4,
	REFUSED			= 5
};

class Name
{
public:
	Name();

	void set_dotted(const std::string & dotted);
	std::string get_dotted() const;

	size_t unmarshal(const char * ptr, size_t size);	// return number of bytes processed
	std::string marshal() const;
private:
	std::string m_data;
};

class Question
{
public:
	typedef uint16_t Qtype;		// 1: host address (A), 255: any
	typedef uint16_t Qclass;	// 1: internet, 255: any
	
	Qtype get_qtype() const { return m_qtype; }
	void set_qtype(Qtype qt) { m_qtype = qt; }

	Qclass get_qclass() const { return m_qclass; }
	void set_qclass(Qclass qt) { m_qclass = qt; }

	Name get_qname() const { return m_qname; }
	void set_qname(const Name & name) { m_qname = name; }

	size_t unmarshal(const char * buff, size_t len); 	// return number of bytes processed
	std::string marshal() const;

private:
	Qtype 	m_qtype;
	Qclass 	m_qclass;
	Name	m_qname;
};

class Resource_record
{
public:
	typedef uint16_t Type;
	typedef uint16_t Class;
	typedef uint32_t TTL;

	Name get_name() const { return m_name; }
	void set_name(const Name & name) { m_name = name; }

	Type get_type() const { return m_type; }
	void set_type(Type t) { m_type = t; }

	Class get_class() const { return m_class; }
	void set_class(Class c) { m_class = c; }

	TTL get_ttl() const { return m_ttl; }
	void set_ttl(TTL ttl) { m_ttl = ttl; }

	std::string get_rdata() const { return m_rdata; }
	void set_rdata(const std::string & rd) { m_rdata = rd; }

	size_t unmarshal(const char * buff, size_t len); 	// return number of bytes processed
	std::string marshal() const;

private:
	Name 		m_name;
	Type		m_type;
	Class		m_class;
	TTL			m_ttl;
	std::string m_rdata;
};

class Message
{
public:

	typedef uint16_t rid_t;
	typedef std::vector<Question> Question_list;
	typedef std::vector<Resource_record> RR_list;

	Message(rid_t rid = 0);

	size_t unmarshal(const char * buff, size_t buflen);
	std::string marshal() const;

	void 	set_rid(rid_t id) { m_rid = id; }
	rid_t 	get_rid() const { return m_rid; }

	bool is_query() const { return m_query; }
	void set_query(bool is_query) { m_query = is_query; }

	Opcode 	get_opcode() const { return m_opcode; }
	void 	set_opcode(Opcode code) { m_opcode = code; }

	bool is_authoritative_answer() const { return m_auth_answer; }
	void set_authoritative_answer(bool aa) { m_auth_answer = aa; }

	bool is_truncated() const { return m_truncated; }
	void set_truncated() { m_truncated = true; }

	bool get_recursion_desired() const { return m_recurs_desired; }
	void set_recursion_desired(bool rd = true) { m_recurs_desired = rd; }

	bool get_recursion_available() const { return m_recurs_availabe; }
	void set_recursion_available(bool ra = true) { m_recurs_availabe = ra; }

	Rcode	get_response_code() const { return m_rcode; }
	void set_response_code(Rcode code) { m_rcode = code; }
	
	Question_list	m_question;
	RR_list			m_answer;
	RR_list			m_authority;
	RR_list			m_additional;
private:
	rid_t 		m_rid;	///< request id - generated by client
	bool 		m_query; ///< whether this is a query or a response
	Opcode		m_opcode; ///< operation code
	bool	    m_auth_answer;
	bool		m_truncated;
	bool		m_recurs_desired;
	bool		m_recurs_availabe;
	Rcode		m_rcode;
};

ostream & operator <<(ostream & os, const Message & msg);
ostream & operator <<(ostream & os, const Name & name);
ostream & operator <<(ostream & os, const Question & question);
ostream & operator <<(ostream & os, const Resource_record & rr);

#include <exception>
#include <string>
class exception : public std::exception
{
public:
	exception(const std::string & msg);
	virtual const char * what() const throw();
	virtual ~exception() throw();
private:
	std::string msg;
};

inline exception not_implemented() { return exception("not implemented"); }

} // namespace DNS

#endif /* _DNS_PROXY__DNS_MESSAGE_ */
